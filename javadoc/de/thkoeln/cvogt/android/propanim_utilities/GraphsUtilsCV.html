<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (11.0.8) on Tue May 25 17:34:19 CEST 2021 -->
<title>GraphsUtilsCV</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-05-25">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="GraphsUtilsCV";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">de.thkoeln.cvogt.android.propanim_utilities</a></div>
<h2 title="Class GraphsUtilsCV" class="title">Class GraphsUtilsCV</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>de.thkoeln.cvogt.android.propanim_utilities.GraphsUtilsCV</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">GraphsUtilsCV</span>
extends java.lang.Object</pre>
<div class="block">This class provides some utility methods for working with graphs, especially for displaying them on a screen.
 A graph can be specified in two ways:<UL>
 <LI> A HashMap: Its key set specifies the set of vertices.
 Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
 i.e. contains all the vertices that are directly connected with the key vertex by an edge.</LI>
 <LI> An SQLite database: It is assumed that the database includes two tables - one specifying the vertices and one specifying the edges.
 The vertex table is required to have a column with primary keys of type INTEGER that uniquely identify the vertices.
 The edge table is required to have two columns specifying the vertices belonging to the edges. The entries of these columns are foreign keys
 of type INTEGER referring to the primary key column of the vertex table.</LI>
 </UL>
 The methods of this class work mainly on the HashMap representation. The auxiliary method <I>generateGraphHashMapFromSQL()</I> generates the
 HashMap representation from a given SQLite database.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">GraphsUtilsCV</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#animateGraphPlacement(java.util.HashMap,de.thkoeln.cvogt.android.propanim_utilities.AnimatedGuiObjectCV,java.util.HashMap,double,int,int)">animateGraphPlacement</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                     <a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>&nbsp;root,
                     java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;positions,
                     double&nbsp;sizeFinal,
                     int&nbsp;roundDuration,
                     int&nbsp;startDelay)</code></th>
<td class="colLast">
<div class="block">Method to add animators to objects of class AnimatedGuiObjectsCV that form a graph.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#animateGraphPlacement(java.util.HashMap,de.thkoeln.cvogt.android.propanim_utilities.AnimatedGuiObjectCV,java.util.HashMap,int,int)">animateGraphPlacement</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                     <a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>&nbsp;root,
                     java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;positions,
                     int&nbsp;roundDuration,
                     int&nbsp;startDelay)</code></th>
<td class="colLast">
<div class="block">Method to add animators to objects of class AnimatedGuiObjectsCV that form a graph.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completeUndirectedGraph(java.util.HashMap)">completeUndirectedGraph</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Auxiliary method to complete an undirected graph: For all edges (x,y), the corresponding edge (y,x) will be added.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#completeUndirectedGraphAnimGuiObj(java.util.HashMap)">completeUndirectedGraphAnimGuiObj</a></span>&#8203;(java.util.HashMap&lt;<a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>,&#8203;java.util.Collection&lt;<a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>&gt;&gt;&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Auxiliary method to complete an undirected graph: For all edges (x,y), the corresponding edge (y,x) will be added.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static java.util.ArrayList&lt;java.util.ArrayList&lt;java.lang.Object&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findComponents(java.util.HashMap)">findComponents</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Method to find the components of a graph.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static java.util.HashMap&lt;java.lang.Integer,&#8203;java.util.HashSet&lt;java.lang.Integer&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generateGraphHashMapFromSQL(android.database.sqlite.SQLiteDatabase,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)">generateGraphHashMapFromSQL</a></span>&#8203;(android.database.sqlite.SQLiteDatabase&nbsp;database,
                           java.lang.String&nbsp;nameVertexTable,
                           java.lang.String&nbsp;colnameVertexPRIK,
                           java.lang.String&nbsp;nameEdgeTable,
                           java.lang.String&nbsp;colnameVertex1FOK,
                           java.lang.String&nbsp;colnameVertex2FOK)</code></th>
<td class="colLast">
<div class="block">Auxiliary method to generate a HashMap representation of a graph from its SQLite representation.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#placeVertices_BalloonLayout(java.util.HashMap,java.lang.Object,int,int,int,int)">placeVertices_BalloonLayout</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                           java.lang.Object&nbsp;root,
                           int&nbsp;left,
                           int&nbsp;top,
                           int&nbsp;right,
                           int&nbsp;bottom)</code></th>
<td class="colLast">
<div class="block">Method to generate the layout for a graph = to calculate the 2D positions of its vertices.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#placeVertices_BipartiteGraphLayout(java.util.HashMap,java.lang.Object,int,int,int,int,int,int)">placeVertices_BipartiteGraphLayout</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                  java.lang.Object&nbsp;root,
                                  int&nbsp;left,
                                  int&nbsp;top,
                                  int&nbsp;right,
                                  int&nbsp;defaultObjectWidth,
                                  int&nbsp;defaultObjectHeight,
                                  int&nbsp;verticalSpacing)</code></th>
<td class="colLast">
<div class="block">Method to generate the layout for a bipartite graph = to calculate the 2D positions of its vertices.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#placeVertices_ForceDirectedLayout(java.util.HashMap,int,int,int,int)">placeVertices_ForceDirectedLayout</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                 int&nbsp;left,
                                 int&nbsp;top,
                                 int&nbsp;right,
                                 int&nbsp;bottom)</code></th>
<td class="colLast">
<div class="block">Method to generate the layout for a graph = to calculate the 2D positions of its vertices.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#placeVertices_TreeLayout(java.util.HashMap,java.lang.Object,int,int,int,int,int)">placeVertices_TreeLayout</a></span>&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                        java.lang.Object&nbsp;root,
                        int&nbsp;left,
                        int&nbsp;top,
                        int&nbsp;right,
                        int&nbsp;bottom,
                        int&nbsp;verticalSpacing)</code></th>
<td class="colLast">
<div class="block">Method to generate the layout for a graph = to calculate the 2D positions of its vertices.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>GraphsUtilsCV</h4>
<pre>public&nbsp;GraphsUtilsCV()</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="findComponents(java.util.HashMap)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findComponents</h4>
<pre class="methodSignature">public static&nbsp;java.util.ArrayList&lt;java.util.ArrayList&lt;java.lang.Object&gt;&gt;&nbsp;findComponents&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph)</pre>
<div class="block">Method to find the components of a graph.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An ArrayList with the components. Each component is represented by an ArrayList with its nodes.</dd>
</dl>
</li>
</ul>
<a id="placeVertices_TreeLayout(java.util.HashMap,java.lang.Object,int,int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>placeVertices_TreeLayout</h4>
<pre class="methodSignature">public static&nbsp;java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;placeVertices_TreeLayout&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                                                                                        java.lang.Object&nbsp;root,
                                                                                                        int&nbsp;left,
                                                                                                        int&nbsp;top,
                                                                                                        int&nbsp;right,
                                                                                                        int&nbsp;bottom,
                                                                                                        int&nbsp;verticalSpacing)</pre>
<div class="block">Method to generate the layout for a graph = to calculate the 2D positions of its vertices.
 The resulting layout will be a tree starting from a vertex marked as the "root" of the tree.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.</dd>
<dd><code>root</code> - The root vertex to start from</dd>
<dd><code>left</code> - Left border of the area where to place the vertices</dd>
<dd><code>top</code> - Upper border of the area where to place the vertices</dd>
<dd><code>right</code> - Right border of the area where to place the vertices</dd>
<dd><code>bottom</code> - Lower border of the area where to place the vertices</dd>
<dd><code>verticalSpacing</code> - The vertical spacing in the tree layout</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A map mapping the vertices of the graph (as given by the key set of the graph parameter) to their positions</dd>
</dl>
</li>
</ul>
<a id="placeVertices_BalloonLayout(java.util.HashMap,java.lang.Object,int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>placeVertices_BalloonLayout</h4>
<pre class="methodSignature">public static&nbsp;java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;placeVertices_BalloonLayout&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                                                                                           java.lang.Object&nbsp;root,
                                                                                                           int&nbsp;left,
                                                                                                           int&nbsp;top,
                                                                                                           int&nbsp;right,
                                                                                                           int&nbsp;bottom)</pre>
<div class="block">Method to generate the layout for a graph = to calculate the 2D positions of its vertices.
 The resulting layout will be a balloon layout centered around a vertex marked as the root of the tree.
 NB: Works currently only for graph that are trees.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.</dd>
<dd><code>root</code> - The root vertex to start from</dd>
<dd><code>left</code> - Left border of the area where to place the vertices</dd>
<dd><code>top</code> - Upper border of the area where to place the vertices</dd>
<dd><code>right</code> - Right border of the area where to place the vertices</dd>
<dd><code>bottom</code> - Lower border of the area where to place the vertices</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A map mapping the vertices of the graph (as given by the key set of the graph parameter) to their positions</dd>
</dl>
</li>
</ul>
<a id="placeVertices_ForceDirectedLayout(java.util.HashMap,int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>placeVertices_ForceDirectedLayout</h4>
<pre class="methodSignature">public static&nbsp;java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;placeVertices_ForceDirectedLayout&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                                                                                                 int&nbsp;left,
                                                                                                                 int&nbsp;top,
                                                                                                                 int&nbsp;right,
                                                                                                                 int&nbsp;bottom)</pre>
<div class="block">Method to generate the layout for a graph = to calculate the 2D positions of its vertices.
 The method uses the algorithm for force-directed vertex placement.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.</dd>
<dd><code>left</code> - Left border of the area where to place the vertices</dd>
<dd><code>top</code> - Upper border of the area where to place the vertices</dd>
<dd><code>right</code> - Right border of the area where to place the vertices</dd>
<dd><code>bottom</code> - Lower border of the area where to place the vertices</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A map mapping the vertices of the graph (as given by the key set of the graph parameter) to their positions</dd>
</dl>
</li>
</ul>
<a id="placeVertices_BipartiteGraphLayout(java.util.HashMap,java.lang.Object,int,int,int,int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>placeVertices_BipartiteGraphLayout</h4>
<pre class="methodSignature">public static&nbsp;java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;placeVertices_BipartiteGraphLayout&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                                                                                                  java.lang.Object&nbsp;root,
                                                                                                                  int&nbsp;left,
                                                                                                                  int&nbsp;top,
                                                                                                                  int&nbsp;right,
                                                                                                                  int&nbsp;defaultObjectWidth,
                                                                                                                  int&nbsp;defaultObjectHeight,
                                                                                                                  int&nbsp;verticalSpacing)</pre>
<div class="block">Method to generate the layout for a bipartite graph = to calculate the 2D positions of its vertices.
 The method starts from a root vertex which is placed at the top-left corner of the designated area.
 The vertices adjacent to the root are placed right-bound in the lines below,
 the vertices adjacent to them left-bound and so on.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.
              It is assumed that the graph is bipartite and connected.</dd>
<dd><code>root</code> - Root vertex from where to start.</dd>
<dd><code>left</code> - Left border of the area where to place the vertices</dd>
<dd><code>top</code> - Upper border of the area where to place the vertices</dd>
<dd><code>right</code> - Right border of the area where to place the vertices</dd>
<dd><code>defaultObjectWidth</code> - The default width of the graphical objects to place (if a graphical object is of class AnimatedGuiObjectCV the actual width is used)</dd>
<dd><code>defaultObjectHeight</code> - The default height of the graphical objects to place (if a graphical object is of class AnimatedGuiObjectCV the actual height is used)</dd>
<dd><code>verticalSpacing</code> - The vertical spacing between the graphical objects</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A map mapping the vertices of the graph (as given by the key set of the graph parameter) to their positions</dd>
</dl>
</li>
</ul>
<a id="animateGraphPlacement(java.util.HashMap,de.thkoeln.cvogt.android.propanim_utilities.AnimatedGuiObjectCV,java.util.HashMap,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>animateGraphPlacement</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;animateGraphPlacement&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                         <a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>&nbsp;root,
                                         java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;positions,
                                         int&nbsp;roundDuration,
                                         int&nbsp;startDelay)</pre>
<div class="block">Method to add animators to objects of class AnimatedGuiObjectsCV that form a graph.
 The animation will start form a root vertex that will be shown first.
 From this root vertex, its adjacent vertices will move linearly to their positions,
 then their adjacent vertices to their positions and so on</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.
              Although not explicitly stated, the key type and the element type of the collection must be AnimatedGuiObjectCV.</dd>
<dd><code>root</code> - Root vertex from where to start the animation.</dd>
<dd><code>positions</code> - The target positions of the vertices.
              Although not explicitly stated, the key type must be AnimatedGuiObjectCV.</dd>
<dd><code>roundDuration</code> - The duration of a round, i.e. the time to move a group of nodes to their positions (in ms)</dd>
<dd><code>startDelay</code> - Delay before the animation starts (in ms)</dd>
</dl>
</li>
</ul>
<a id="animateGraphPlacement(java.util.HashMap,de.thkoeln.cvogt.android.propanim_utilities.AnimatedGuiObjectCV,java.util.HashMap,double,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>animateGraphPlacement</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;animateGraphPlacement&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph,
                                         <a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>&nbsp;root,
                                         java.util.HashMap&lt;java.lang.Object,&#8203;android.graphics.Point&gt;&nbsp;positions,
                                         double&nbsp;sizeFinal,
                                         int&nbsp;roundDuration,
                                         int&nbsp;startDelay)</pre>
<div class="block">Method to add animators to objects of class AnimatedGuiObjectsCV that form a graph.
 The animation will start form a root vertex that will be shown first.
 From this root vertex, its adjacent vertices will move linearly to their positions,
 then their adjacent vertices to their positions and so on.
 After playing, the animators will be removed from the animator lists of the objects
 and hence will not be replayed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.
              Although not explicitly stated, the key type and the element type of the collection must be AnimatedGuiObjectCV.</dd>
<dd><code>root</code> - Root vertex from where to start the animation.</dd>
<dd><code>positions</code> - The target positions of the vertices.
              Although not explicitly stated, the key type must be AnimatedGuiObjectCV.</dd>
<dd><code>sizeFinal</code> - The final sizes of the vertices, relative to their initial sizes (e.g.: 2.0 = double size, 0.5 = half size, 1 = no animation).</dd>
<dd><code>roundDuration</code> - The duration of a round, i.e. the time to move a group of nodes to their positions (in ms).</dd>
<dd><code>startDelay</code> - Delay before the animation starts (in ms).</dd>
</dl>
</li>
</ul>
<a id="generateGraphHashMapFromSQL(android.database.sqlite.SQLiteDatabase,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generateGraphHashMapFromSQL</h4>
<pre class="methodSignature">public static&nbsp;java.util.HashMap&lt;java.lang.Integer,&#8203;java.util.HashSet&lt;java.lang.Integer&gt;&gt;&nbsp;generateGraphHashMapFromSQL&#8203;(android.database.sqlite.SQLiteDatabase&nbsp;database,
                                                                                                                          java.lang.String&nbsp;nameVertexTable,
                                                                                                                          java.lang.String&nbsp;colnameVertexPRIK,
                                                                                                                          java.lang.String&nbsp;nameEdgeTable,
                                                                                                                          java.lang.String&nbsp;colnameVertex1FOK,
                                                                                                                          java.lang.String&nbsp;colnameVertex2FOK)</pre>
<div class="block">Auxiliary method to generate a HashMap representation of a graph from its SQLite representation.
 The SQLite database is assumed to include two tables - one specifying the vertices and one specifying the edges.
 The vertex table is required to have a column with primary keys of type INTEGER that uniquely identify the vertices.
 The edge table is required to have two columns specifying the vertices belonging to the edges. The entries of these columns are foreign keys
 of type INTEGER, referring to the primary key column of the vertex table.
 The key set of the returned HashMap is the set of vertices. Each key (= vertex) is mapped to a collection that specifies the adjacency list
 of this vertex, i.e. contains all the vertices that are directly connected with the key vertex by an edge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>database</code> - The SQLite database specifying the graph.</dd>
<dd><code>nameVertexTable</code> - The name of the database table specifying the vertices.</dd>
<dd><code>colnameVertexPRIK</code> - The name of the column of the vertex table with the primary keys of the vertices.</dd>
<dd><code>nameEdgeTable</code> - The name of the database table specifying the edges.</dd>
<dd><code>colnameVertex1FOK</code> - The name of the column of the edge table with the foreign keys of the first vertices of the edges.</dd>
<dd><code>colnameVertex2FOK</code> - The name of the column of the edge table with the foreign keys of the second vertices of the edges.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The corresponding HashMap, as described above.</dd>
</dl>
</li>
</ul>
<a id="completeUndirectedGraph(java.util.HashMap)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completeUndirectedGraph</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;completeUndirectedGraph&#8203;(java.util.HashMap&lt;java.lang.Object,&#8203;java.util.Collection&gt;&nbsp;graph)</pre>
<div class="block">Auxiliary method to complete an undirected graph: For all edges (x,y), the corresponding edge (y,x) will be added.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.</dd>
</dl>
</li>
</ul>
<a id="completeUndirectedGraphAnimGuiObj(java.util.HashMap)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>completeUndirectedGraphAnimGuiObj</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;completeUndirectedGraphAnimGuiObj&#8203;(java.util.HashMap&lt;<a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>,&#8203;java.util.Collection&lt;<a href="AnimatedGuiObjectCV.html" title="class in de.thkoeln.cvogt.android.propanim_utilities">AnimatedGuiObjectCV</a>&gt;&gt;&nbsp;graph)</pre>
<div class="block">Auxiliary method to complete an undirected graph: For all edges (x,y), the corresponding edge (y,x) will be added.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - The graph as a HashMap: Its key set specifies the set of vertices.
              Each key (= vertex) is mapped to a collection that specifies the adjacency list of this vertex,
              i.e. contains all the vertices that are directly connected with the key vertex by an edge.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
